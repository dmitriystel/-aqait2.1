package by.a1qa.task2_1.page;

public class SearchStep {


    // SearchPage searchPage = new SearchPage();
// public class SearchSteps extends SteamSteps<SearchSteps>


    private static final String resultXpath = "//div[@id='search_resultsRows']//a"; // строки игр по порядку
    private static final String nameXpath = ".//span[contains(@class, 'title')]"; // имя игры по порядку
    private static final String platformXpath = ".//span[contains(@class, 'platform')]"; // имя платформы по порядку
    private static final String releaseDateXpath = ".//div[contains(@class, 'release')]"; // релиз по порядку
    private static final String reviewSummaryResultXpath = ".//span[contains(@class, 'review')]"; // ревью по порядку
    private static final String priceXpath = ".//div[contains(@class, 'price')]//div[contains(@class, 'price')]"; // цены по порядку


}



    /*
       Дима Чесноков ответил:

    самым правильным способом здесь будет реализовать самый верхний элемент (по сути "строку" в которой хранится инфа
    об одной конкретной игре) вынести в отдельный пейдж обжект. И в этом пейдж обжекте прописать все локаторы
    (имени, цены и тд), благодаря этому вы сможете найти список всех игр в виде списка объектов и в таком случае
    использование индексов в локаторах отпадает. вы просто будет получать первую игру из списка объектов и обращать по
    индексу списка ну либо же получать список именно объекта Game тоже вариант

    Да, я поправил это, по сути получением List<WebElement> и забираем первых n элементов из него

    Строку получить это локатор где на конце будет //a

    по resultXpath получаем лист из веб-элементов
    дальше уже у каждого элемента по остальным локаторам "парсим" соответствующие поля

    ну я как итог собираю результаты в объект Game



    Тимофей ответил:
Ну, я вначале получаю список gameRows через xpath //a[contains(@class,'search_result_row')]

А потом в foreach пробегаюсь и для каждого элемента вызываю метод getGameInfo, передавая элемент туда в качестве
 параметра. Ны выходе у меня объект с инфой об игре. Каждый объекта засовываю в ArrayList

Внутри метода я ищу нужную инфу в каждой строке с игрой

Но нужно искать именно внутри переданного в качестве параметра элемента. Т.е. брать элемент за основу,
 нашу ссылку 'a' конкретную найденную

А для этого a.findElement(и тут  xpath, начинающийся с точки; например: .//span...)

Я, например, не знал просто про эту точку и у меня не выходило. Я пытался искать внутри элемента
 и писать просто "//span". Но так оно просто складывает как-то xpath ссылки 'a' и новый xpath и ищет опять во всём
  документа, а не внутри элемента, и, конечно, без индекса не работает тогда. Я так понял





     */
